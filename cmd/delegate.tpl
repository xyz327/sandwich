// Code generated by go generate; DO NOT EDIT.
{{define "parseParam" }}{{range $i,$v:=.}}{{if eq $i 0}}{{else}},{{end}} {{.Name}} {{if .Ellipsis}}...{{end}}{{if $v.Ptr}}*{{end}}{{$v.Typed}}{{end}}{{end}}
{{define "paramName"}}{{range $i,$v:=.}}{{if eq $i 0}}{{else}},{{end}} {{.Name}}{{end}}{{end}}
{{define "invokeTyped"}}({{if .Ellipsis}}[]{{end}}{{if .Ptr}}*{{end}}{{.Typed}}){{if .Ellipsis}}...{{end}}{{end}}
{{define "invokeArgs"}}{{range $i,$v:=.}}{{if eq $i 0}}{{else}},{{end}}_params[{{$i}}].Value.{{template "invokeTyped" $v}}{{end}}{{end}}
package {{.PackageName}}
{{range .Imports}}
import {{.Name}} {{.Path}}
{{end}}
var _ sandwich.Wrapper[{{$.DelegateName}}] = (*{{$.TypeName}})(nil)
{{range .FuncTypes}}
type {{.Name}} {{.Type}}
{{end}}
func (c *{{$.TypeName}}) _delegateCall(invoke *sandwich.Invoke){
    defer func() {
        if !invoke.IsProceed() {
            invoke.Process()
        }
    }()
    c.WrapperMethod(invoke.Ctx, invoke)
}
{{range .Interfaces}}
// implements {{.Name}}
{{range .Methods}}
func (c *{{$.TypeName}}) {{.Name}}({{template "parseParam" .Args}}) ({{template "parseParam" .Returns}}) {
	_params := []*sandwich.Valued{
		{{range .Args}}{Name: "{{.Name}}", Value: {{.Name}} },{{end}}
	}
    invoke := &sandwich.Invoke{Ctx:{{if eq .CtxName ""}}context.Background(){{else}}{{.CtxName}}{{end}},MethodName: "{{.Name}}",Params:  _params}
    invoke.SetProcess(func() []*sandwich.Valued{
        {{$len := len .Returns}}{{if eq 0 $len}}c.GetDelegate().{{.Name}}({{template "invokeArgs" .Args}}){{else}}
        {{template "paramName" .Returns}} = c.GetDelegate().{{.Name}}({{template "invokeArgs" .Args}})
        invoke.Returns=make([]*sandwich.Valued,{{len .Returns}})
        {{range $i,$v:=.Returns}} invoke.Returns[{{$i}}] = &sandwich.Valued{Name: "{{$v.Name}}", Value: {{$v.Name}}}; {{end}}{{end}}
        return invoke.Returns

    })
    c._delegateCall(invoke)
    return
}
{{end}}
{{end}}